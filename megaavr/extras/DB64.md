# AVR128DA64/AVR64DA64
## Pin Mapping / Pinout
![DA64 Pin Mapping](DB64.png "Arduino Pin Mapping for DA64")

## Features and Peripherals
|                              | AVR64DA64  | AVR128DA64 |
|------------------------------|------------|------------|
| Flash Memory                 | 65536      | 131072     |
| SRAM                         | 8192       | 16384      |
| EEPROM                       | 512        | 512        |
| User Row                     | 32         | 32         |
| Max. Frequency (MHz)         | 24         | 24         |
| Total pins on package        | 64         | 64         |
| Packages Available           | TQFP, VQFN | TQFP, VQFN |
| I/O Pins, not counting Reset | 54         | 54         |
| 16-bit Type A Timer (TCA)    | 2          | 2          |
| 16-bit Type B Timer (TCB)    | 5          | 5          |
| 12-bit Type D Timer (TCD)    | 1          | 1          |
| USART                        | 6          | 6          |
| SPI                          | 2          | 2          |
| TWI/I2C                      | 2          | 2          |
| 12-bit Differential ADC      | 22         | 22         |
| 10-bit DAC                   | 1          | 1          |
| Analog Comparator (AC)       | 3          | 3          |
| Zero-Cross Detectors (ZCD)   | 3          | 3          |
| Custom Logic LUTs            | 6          | 6          |
| Event System channels        | 10         | 10         |

## Notes
* The Type A timers (TCA0 and TCA1) can be mapped to different pins as a group only - you can set TCA0 to output on any port's pin 0-5, and TCA1 to PORTB or PORTG (the configurations on pins 4-6 of PORTC or PORTE are not supported - too much overhead every time analogWrite or digitalWrite is called). Using this feature is easy - all you need to do is `PORTMUX.TCAROUTEA` and then analogWrite() normally. It is suggested to not have any PWM output enabled when setting `PORTMUX.TCAROUTEA`. 
```
PORTMUX.TCAROUTEA = PORTMUX_TCA0_PORTF_gc | PORTMUX_TCA1_PORTG_gc; // PWM on PORTF and PORTG pins 0-5 
PORTMUX.TCAROUTEA = (PORTMUX.TCAROUTEA & PORTMUX_TCA0_gm) | PORTMUX_TCA1_PORTG; // Move TCA1 PWM to PORTG but don't change TCA0
// The first option is slightly faster, as it isn't a read-modify-write. 
// Note that PORTMUX_TCA0_PORTA_gc and PORTMUX_TCA1_PORTB_gc have a numeric value of 0.
```
* The Type D timer, TCD0, has 2 output channels (WOA and WOB) and 4 output pins (WOA, WOB, WOC, and WOD). The hardware permits WOC and WOD to each output either WOA or WOB, but this added too much complexity to analogWrite; WOA and WOC output WOA, and WOD and WOB output WOB. Calling analogWrite() on either pin will enable it, calling digitalWrite() on that pin will turn the PWM off. Calling analogWrite() on WOC while already outputting on the WOA pin will result in both pins outputting the new duty cycle. Call digital write on first pin if this is not what you want. The datasheet describes TCD0 output on PA4-7, PB4-7, PF0-3, and PG4-7. What the datasheet giveth, the errata taketh away; the alternate pin options are hopelessly broken currently, only PA4-7 work.
* Following precedent set by MegaCoreX, we declare that pin 7 - `PIN_PA7` shall be the pin that the core "expects" to be connected to an LED. LED_BUILTIN is defined as that pin, and the bootloader will set that pin as output and try to blink the LED. Note that if the bootloader is not used, and your sketch does not reference `LED_BUILTIN` this pin is not otherwise treated any differently. This can be overridden if a custom board definition is created by passing `-DLED_BUILTIN = (some other pin)` in the `build.extra_flags` field. 
* Reset (PF6) can be set to work as an input (but never an output). The UPDI pin cannot be configured as an I/O pin. 
* Only pins on PORTD and PORTE can be used as the negative side of a differential analog reading (`analogReadDiff()`).
* If MVIO is enabled (the default), the VDDIO2 pin may be powered independently of VDD. No harm will come to the device if VDDIO2 it is powered when the rest of the chip is not, or if the rest of the chip is powered and VBDDIO2 is not. The voltage on VDDIO2 has the same maximum as VDD (5.5v max recommended, 6.0V abs. max), and it must share a common ground with the VDD supply, but it may be higher or lower than VDD. If VDDIO2 is at least 1.65V, PORTC will be enabled, and the pins will behave as if the device was running from that voltage. Software can check `MVIO.STATUS` to determine if the pins have sufficient voltage to operate. 
  * If you do not need to drive a load you can use the OPAMP peripheral and DAC to provide that voltage. Configure an OPAMP in voltage follower mode using the included [Opamp library](../libraries/Opamp/README.md), set it to use the DAC as it's positive input, and connect a jumper between the DAC output and the VDDIO2 pin. In this configuration, you should not expect much current (any current supplied by PORTC pins must come from VDDIO2); at 5V, they spec. a short circuit sourcing current of 33mA and the maximum output voltage as 0.1V below VDD at 3.5mA with approximately linear dependance below that current.  They do not specify at what current the voltage nosedives at.
  * If MVIO is not enabled (this reduces current consumption by around 0.5 uA) you must have VDDIO2 connected externally to VDD, otherwise proper port functioning should not be expected. In my tests, it still used the VDDIO2 voltage on that port, but the voltage that it started functioning at was not well defined, and the pins would read garbage, rather than 0 when the pin was not powered. Prolonged use in that way might (or might not) damage the chip long term, but it does not cause immediate destruction as some had feared initially.
## Datasheets

[AVR128DB Datasheet](https://ww1.microchip.com/downloads/en/DeviceDoc/AVR128DB28-32-48-64-DataSheet-DS40002247A.pdf)

[AVR128DB Errata](https://ww1.microchip.com/downloads/en/DeviceDoc/AVR128DB28-32-48-64-SilConErrataClarif-DS80000915B.pdf)
