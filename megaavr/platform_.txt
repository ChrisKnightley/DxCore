
####################################
# Export Compiled Binary and more  #
####################################
# Export Compiled Binary will also #
# generate an assembly listing and #
# memory map for hand debugging,   #
# optimization and analysis.       #
####################################

## Save hex
# Needs to be specified separately, because otherwise some parts of it don't resolve for reasons I dont understand.
recipe.output.tmp_file={build.project_name}.hex
recipe.output.save_file={build.project_name}.{build.mcu}{build.mcupostfix}.{build.speed}c{build.clocksource}.m{build.millistimer}{build.wireabr}{build.printfabr}{build.appspmabr}{build.attachabr}.v{versionnum.major}{versionnum.minor}{versionnum.patch}.hex

## Extra asset name (for .lst and .map output - doesn't fully resolve for .hex)
build.extraassetname={build.project_name}.{build.mcu}{build.mcupostfix}.{build.speed}c{build.clocksource}.m{build.millistimer}{build.wireabr}{build.printfabr}{build.appspmabr}{build.attachabr}.v{versionnum.major}{versionnum.minor}{versionnum.patch}

## Create disassembler listing
recipe.hooks.objcopy.postobjcopy.1.pattern.windows=cmd /C "{compiler.path}{compiler.objdump.cmd}" {compiler.objdump.flags} "{build.path}/{build.project_name}.elf" > "{build.path}/{build.project_name}.lst"
recipe.hooks.objcopy.postobjcopy.1.pattern.linux=bash -c "{compiler.path}{compiler.objdump.cmd} {compiler.objdump.flags} {build.path}/{build.project_name}.elf > {build.path}/{build.project_name}.lst"
recipe.hooks.objcopy.postobjcopy.1.pattern.macosx=bash -c "{compiler.path}{compiler.objdump.cmd} {compiler.objdump.flags} {build.path}/{build.project_name}.elf > {build.path}/{build.project_name}.lst"

## Create memory map
recipe.hooks.objcopy.postobjcopy.2.pattern.windows=cmd /C "{compiler.path}{compiler.nm.cmd}" {compiler.nm.flags}  "{build.path}/{build.project_name}.elf" > "{build.path}/{build.project_name}.map"
recipe.hooks.objcopy.postobjcopy.2.pattern.linux=bash -c "{compiler.path}{compiler.nm.cmd} {compiler.nm.flags}  {build.path}/{build.project_name}.elf > {build.path}/{build.project_name}.map"
recipe.hooks.objcopy.postobjcopy.2.pattern.macosx=bash -c "{compiler.path}{compiler.nm.cmd} {compiler.nm.flags}  {build.path}/{build.project_name}.elf > {build.path}/{build.project_name}.map"

## Save assembly listing
recipe.hooks.savehex.presavehex.1.pattern.windows=cmd /C copy "{build.path}\{build.project_name}.lst" "{sketch_path}\{build.extraassetname}.lst"
recipe.hooks.savehex.presavehex.1.pattern.linux=cp "{build.path}/{build.project_name}.lst" "{sketch_path}/{build.extraassetname}.lst"
recipe.hooks.savehex.presavehex.1.pattern.macosx=cp "{build.path}/{build.project_name}.lst" "{sketch_path}/{build.extraassetname}.lst"

## Save memory map
recipe.hooks.savehex.presavehex.2.pattern.windows=cmd /C copy "{build.path}\{build.project_name}.map" "{sketch_path}\{build.extraassetname}.map"
recipe.hooks.savehex.presavehex.2.pattern.linux=cp "{build.path}/{build.project_name}.map" "{sketch_path}/{build.extraassetname}.map"
recipe.hooks.savehex.presavehex.2.pattern.macosx=cp "{build.path}/{build.project_name}.map" "{sketch_path}/{build.extraassetname}.map"

#########################################
# avrdude - the classic AVR upload tool #
# Currently used for all non-SerialUPDI #
# programming tools.                    #
# Would love to replace most of this    #
# with new python upload tools.         #
#########################################

## Unused but required parameters
# Uploading without verification is prohibited. Since there is no checksum or verification of success at any point in the upload process otherwise,
# if verification was disabled, an upload problem could look like a code problem, and you could debug it unsuccessfully for days with no progress.
tools.avrdude.program.verify=
tools.avrdude.upload.verify=
# the erase pattern, if defined, is used I think immediately prior to bootloading only, but bootloading can be done in a single operation; there is no need for this.
tools.avrdude.erase.params.verbose=
tools.avrdude.erase.params.quiet=
tools.avrdude.erase.pattern=

## avrdude-related paths
tools.avrdude.path={runtime.tools.avrdude.path}
tools.avrdude.cmd.path={path}/bin/avrdude
tools.avrdude.config.path={runtime.platform.path}/avrdude.conf
tools.avrdude.network_cmd={runtime.tools.arduinoOTA.path}/bin/arduinoOTA

## Used for Sketch -> Upload using Programmer or uploads without a bootloader
tools.avrdude.program.params.verbose=-v
tools.avrdude.program.params.quiet=-q -q
tools.avrdude.program.params.noverify=-V
tools.avrdude.program.pattern={upload.prog_interlock}"{cmd.path}" "-C{config.path}" {program.verbose} {program.verify} -p{build.mcu} -c{protocol} {program.extra_params} "-Ufuse5:w:{bootloader.SYSCFG0}:m" "-Ufuse6:w:{bootloader.SYSCFG1}:m" "-Ufuse7:w:{bootloader.CODESIZE}:m" "-Ufuse8:w:{bootloader.BOOTSIZE}:m""-Ufuse9:w:{bootloader.CODEIZE}:m" "-Uflash:w:{build.path}/{build.project_name}.hex:i"

## Used for "upload" through bootloader
tools.avrdude.upload.params.verbose=-v
tools.avrdude.upload.params.quiet=-q -q
tools.avrdude.upload.params.noverify=-V
tools.avrdude.upload.pattern="{cmd.path}" "-C{config.path}" {upload.verbose} {upload.verify} -p{build.mcu} -c{upload.protocol} {upload.extra_params} -P{serial.port} -b{upload.speed} "-Uflash:w:{build.path}/{build.project_name}.hex:i"

## Used for Tools -> Burn Bootloader
tools.avrdude.bootloader.params.verbose=-v
tools.avrdude.bootloader.params.quiet=-q -q
tools.avrdude.bootloader.pattern="{cmd.path}" "-C{config.path}" {bootloader.verbose} -p{build.mcu} -c{protocol} {program.extra_params} -e "-Ufuse0:w:{bootloader.WDTCFG}:m" "-Ufuse1:w:{bootloader.BODCFG}:m" "-Ufuse5:w:{bootloader.SYSCFG0}:m" "-Ufuse6:w:{bootloader.SYSCFG1}:m" "-Ufuse7:w:{bootloader.BOOTSIZE}:m"  "{bootloader.avrdudestring}"

## OTA/Remote upload
# This functionality has never been tested with these parts. The maintainers of this core have no idea what this is, or whether it is expected to work.
tools.avrdude_remote.upload.pattern=/usr/bin/run-avrdude /tmp/sketch.hex {upload.verbose} -p{build.mcu}
tools.avrdude.upload.network_pattern="{network_cmd}" -address {serial.port} -port 65280 -username arduino -password "{network.password}" -sketch "{build.path}/{build.project_name}.bin" -upload /sketch -d -v

##############################################################
# Serial UPDI - UPDI uploads using a serial adapter directly #
##############################################################
# Board manager installations have the python executable in  #
# different location than a manual installation. The package #
# build script deletes the line starting with                #
# tools.serialupdi.cmd                                       #
# and the #REMOVE#, leaving the correct path.                #
##############################################################

tools.serialupdi.cmd={runtime.platform.path}/tools/python3/python3
#REMOVE#tools.serialupdi.cmd={runtime.tools.python3.path}/python3

## Unused Parameters.
# SerialUPDI has only one level of verbosity.
# There's an *actual* internal verbose mode, but it is WAY too verbose and results >500kb log files which are mostly useless.
# Verification is not optional as there are no guardrails against unsuccessful uploads other than protocol failures
# Upload is only for uploading through a bootloader, and erase is not used anywhere.
tools.serialupdi.bootloader.params.noverify=
tools.serialupdi.bootloader.params.quiet=
tools.serialupdi.bootloader.params.verbose= -v
tools.serialupdi.bootloader.verify=
tools.serialupdi.erase.params.quiet=
tools.serialupdi.erase.params.verbose= -v
tools.serialupdi.erase.pattern=
tools.serialupdi.program.params.noverify=
tools.serialupdi.program.params.quiet=
tools.serialupdi.program.params.verbose= -v
tools.serialupdi.program.verify=
tools.serialupdi.upload.params.noverify=
tools.serialupdi.upload.params.quiet=
tools.serialupdi.upload.params.verbose= -v
tools.serialupdi.upload.verify=
tools.serialupdi.upload.pattern=echo "This can't happen, but has to be here or automated tests fail"

## Tools -> Burn Bootloader pattern
# write fuses 0, 1, 2, 5, 6, 7, 8.
# 2 is always written 0 (sets clock to use HF osc, not 32kHz ULP).
# Fuses 3 and 4 are reserved.
tools.serialupdi.bootloader.pattern="{cmd}" -u "{runtime.platform.path}/tools/prog.py" -t {protocol} {program.extra_params} -d {build.mcu} --fuses 0:{bootloader.WDTCFG} 1:{bootloader.BODCFG} 2:0x00 5:{bootloader.SYSCFG0} 6:{bootloader.SYSCFG1} 7:{bootloader.CODESIZE} 8:{bootloader.BOOTSIZE} 9:{bootloader.CODESIZE} {bootloader.pymcuprogstring} {bootloader.verbose}

## Program pattern (all uploads through SerialUPDI)
# Program will set fuses 2, 6 and 8 only. Fuses 0 and 4 are not written because the core never configures that.
# If a user went and set that themselvesm we shouldn't undo it.
# Fuse 1 is the BOD configuration, which could "brick" the chip if set for a higher voltage than the power rail.
# Fuse 5 is SYSCFG0 which could disable UPDI and leave the board programmable without HV programming.
# That leaves OSCCFG to choose 16 vs 20 MHz clock, and SYSCFG1 (for startup time and stuff) and BOOTEND,
# ensuring that a part previously set to use a bootloader will be unbootloaded cleanly, instead of the
# bootloader being erased but no sketches working)

tools.serialupdi.program.pattern={upload.prog_interlock}"{cmd}" -u "{runtime.platform.path}/tools/prog.py"  -t {protocol} {program.extra_params} -d {build.mcu}{upload.workaround} --fuses 2:{bootloader.OSCCFG} 6:{bootloader.SYSCFG1} 7:{bootloader.APPEND} 8:{bootloader.BOOTEND} "-f{build.path}/{build.project_name}.hex" -a write {program.verbose}

###############
# Expert Mode #
###############
# Expert mode will set SYSCFG0 as well, allowing an upload to disable the UPDI pin.
# This may be used if you have an HV UPDI programmer and wish to upload while setting
# SYSCFG0 including RSTPINCFG. In that case you may uncomment this and comment out the corresponding lines above.

## For avrdude - tools exist
#tools.avrdude.program.pattern="{cmd.path}" "-C{config.path}" {program.verbose} -p{build.mcu}{upload.workaround} -c{protocol} {program.extra_params} "-Ufuse2:w:{bootloader.OSCCFG}:m" "-Ufuse5:w:{bootloader.SYSCFG0}:m" "-Ufuse6:w:{bootloader.SYSCFG1}:m" "-Ufuse6:w:{7:{bootloader.APPEND}m"  "-Ufuse8:w:{bootloader.BOOTEND}:m" "-Uflash:w:{build.path}/{build.project_name}.hex:i"

## For HyperUPDI super-powered HV programming tools under development
#tools.hyperupdi.program.pattern="{cmd}" -u "{runtime.platform.path}/tools/hyperUPDI.py" {program.extra_params} -m{program.mode} -d {build.mcu} --fuses 2:{bootloader.OSCCFG} 5:{bootloader.SYSCFG0}  6:{bootloader.SYSCFG1} 7:{bootloader.APPEND} 8:{bootloader.BOOTEND} "-f{build.path}/{build.project_name}.hex" -a write {program.verbose}
